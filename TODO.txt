/*
 * This file is part of the focus-resources-server package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
 
 POST can conflict with deleted version because of retention policy
 
 put schemas in other repo
 
 GET <resource>
	1. access control checks
	2. resource exists? if not error
	3. retrieve JSON object

POST <resource>
	1. access control checks
	2. is there a type? if not error
	3. check content against schema. if fail -> error
	4. store
	5. enforce data retention policies

PUT <resource>
	1. access control checks
	2. resource exists? if not error
	3. is there a type? if not error
	4. check content against schema. if fail -> error
	5. store
	6. enforce data retention policies

DELETE <resource>
	1. access control checks
	2. resource exists? if not exit
	2. enforce data retention policy (e.g. MUST_KEEP_ONE, REALLY_DELETE, ARCHIVE, ...)


synchronization of data -> require sequence number??? how would that work?
GET /resources
{
rsrc1/v3: lastid
resrc2/v5: lastid
}
=>
{
{rsrc1v3: ok}
{rsrc2/v5: newdata}
}
	
We are a OAuth2 resource server




use monolog to log?


get latest jsv4 before building:
cd contrib && git clone https://github.com/geraintluff/jsv4-php.git

use composer?

curl -X POST -D - -d @sample.json http://example.com/path/to/resource --header "Content-Type:application/json"


Migration mechanism in case we change schemas
Migration of database structure?

Listing of all schemas. When on index.php? or schemas?

use namespaces
use composer?
use Unit Testing

nested schemas

readonly property -> JSON hyperschema

all schemas are stored on fs
all objects are stored in db

but schemas are also objects => could be stored in db / but not ok, because may not belong to local server
	-> keep it on original url
	
	
JSON Schema:
	- nested schemas validation?
	- how to express that some fields are required on creation, some are forbidden
		-> validation on backend only -> schema must match the expectations of the backend, not of the client.
				for example editor should always be '' from the backend perspective, or non-existent.
	
NOTE:
owner could be someone else than the initiator of the POST ????? (we give ownership of created data)

only accept json content type request.


"id": "http://schemas.focusnet.eu/repository/focus-object/v0.1#",


on schema update ==> migrate whole database
	=> check 
	
	if old data with new version of app => ok, backward compatibility
	if  new data with old app => failure, exception raised by GSON => ask user to update.



'active' field -> not sure whether that's good to have it in object/database.
Perhaps another table can keep track of that.
would be simpler
can we access archived samples? NO archived object, not sample ====> makes a lot of sense.

if archive -> POST allowed again? now, I don't think so. because that would override an existing resource
	=> un-archive ????? may be another resource type... => CONFLICT and that's it, at least for now.


chekc timezones PHP <-> database (TIMESTAMP fields)

everything is stored as UTC in db.

at some point: 	"additionalProperties": false
	=> makes a schema final. May be useful, but don't abuse!


Use exceptions!

coding style:
- move from 
	blah 
			or error
	to something more usual
	
UPDATE table => problemes - comme pour 'active'
	
convention: NEVER trailing / to resource identifier.
	
database structure:
===================
(we only keep what helps quickly retrieving data)

-- timestamp makes timezone <-> UTC conversion automatically
-- we rather use datetime and let the application handle these conversions. better control.

-- limit url, type to 245 chars without version, 255 with version
-- we may create indexes on owner, editor if that helps
 



focus-data-container
====================
all data must be key-value pairs in data object
e.g. type == machine-abc-data
	- engine_temp = float
	- engine_rpm = integer
	- ...
==> when mobile app does store, we define the mappings in the data collection process:
	- val1 => engine_temp
	- val2 => integer
and the target type
	- machine-abc-data
===> will just create a new focus-data-container object with the key-value pairs,
	and submit it with type === machine-abc-data
... the backend is then responsible for checking the input (and possibly coerce it)
HENCE the app is schema agnostic, but we still keep some semantic and data validation
		but the app content designer must respect the semantic.