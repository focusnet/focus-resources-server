/*
 * This file is part of the focus-resources-server package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
 
 POST can conflict with deleted version because of retention policy
 
 
 return errors as json objects?
 
 
 
 
 
 
 
 
 important:
 http://www.spinics.net/lists/apache-users/msg104136.html
 I ended up figuring this out and I thought I would respond to my original message to let anyone know who stumbles on this what the problem was.

Apache does not want to send arbitrary HTTP request methods to regular files. Sending a "DELETE" or "PUT" to a regular file in a document root will end up with a "405 Method not allowed", even if the method is "Allow"d (e.g. "Allow from all"... We're kind of overloading the term "Allowed" here!). That is, unless you're using dav/dav_fs, which isn't what I'm trying to do here. If the document being processed is a script, like PHP, Apache is normally willing to forward the request to the file with the REQUEST_METHOD populated.

The issue comes down to how Apache integrates with PHP. In my case, under Ubuntu 12.04, there were two packages:

libapache2-mod-php5 and libapache2-mod-php5filter

I had accidentally installed the "libapache2-mod-php5filter" package, which integrates with Apache using the following lines:

SetInputFilter PHP
SetOutputFilter PHP

These functions are specifically geared toward GET (Output) & POST (Input) operations and don't instruct Apache to pass all request methods to PHP. For all other request methods, Apache treats the .php file as a standard file. I uninstalled libapache2-mod-php5filter and installed libapache2-mod-php5, which integrates with:

<FilesMatch "\.ph(p3?|tml)$">
    SetHandler application/x-httpd-php
</FilesMatch>

The SetHandler accepts all request methods, including the PUT & DELETE I was trying to get working. Hope this helps someone out there.
 
 
 
 
 
 
 put schemas in other repo
 
 GET <resource>
	1. access control checks
	2. resource exists? if not error
	3. retrieve JSON object

POST <resource>
	1. access control checks
	2. is there a type? if not error
	3. check content against schema. if fail -> error
	4. store
	5. enforce data retention policies

PUT <resource>
	1. access control checks
	2. resource exists? if not error
	3. is there a type? if not error
	4. check content against schema. if fail -> error
	5. store
	6. enforce data retention policies

DELETE <resource>
	1. access control checks
	2. resource exists? if not exit
	2. enforce data retention policy (e.g. MUST_KEEP_ONE, REALLY_DELETE, ARCHIVE, ...)


synchronization of data -> require sequence number??? how would that work?
GET /resources
{
rsrc1/v3: lastid
resrc2/v5: lastid
}
=>
{
{rsrc1v3: ok}
{rsrc2/v5: newdata}
}
	
We are a OAuth2 resource server




use monolog to log?


get latest jsv4 before building:
cd contrib && git clone https://github.com/geraintluff/jsv4-php.git

use composer?

curl -X POST -D - -d @sample.json http://example.com/path/to/resource --header "Content-Type:application/json"


Migration mechanism in case we change schemas
Migration of database structure?

Listing of all schemas. When on index.php? or schemas?

use namespaces
use composer?
use Unit Testing

nested schemas

readonly property -> JSON hyperschema

all schemas are stored on fs
all objects are stored in db

but schemas are also objects => could be stored in db / but not ok, because may not belong to local server
	-> keep it on original url
	
	
JSON Schema:
	- nested schemas validation?
	- how to express that some fields are required on creation, some are forbidden
		-> validation on backend only -> schema must match the expectations of the backend, not of the client.
				for example editor should always be '' from the backend perspective, or non-existent.
	
NOTE:
owner could be someone else than the initiator of the POST ????? (we give ownership of created data)

only accept json content type request.


"id": "http://schemas.focusnet.eu/repository/focus-object/v0.1#",


on schema update ==> migrate whole database
	=> check 
	
	if old data with new version of app => ok, backward compatibility
	if  new data with old app => failure, exception raised by GSON => ask user to update.



'active' field -> not sure whether that's good to have it in object/database.
Perhaps another table can keep track of that.
would be simpler
can we access archived samples? NO archived object, not sample ====> makes a lot of sense.

if archive -> POST allowed again? now, I don't think so. because that would override an existing resource
	=> un-archive ????? may be another resource type... => CONFLICT and that's it, at least for now.


chekc timezones PHP <-> database (TIMESTAMP fields)

everything is stored as UTC in db.

at some point: 	"additionalProperties": false
	=> makes a schema final. May be useful, but don't abuse!


Use exceptions!

coding style:
- move from 
	blah 
			or error
	to something more usual
	
UPDATE table => problemes - comme pour 'active'
	
convention: NEVER trailing / to resource identifier.
	
database structure:
===================
(we only keep what helps quickly retrieving data)

-- timestamp makes timezone <-> UTC conversion automatically
-- we rather use datetime and let the application handle these conversions. better control.

-- limit url, type to 245 chars without version, 255 with version
-- we may create indexes on owner, editor if that helps
 



focus-data-container
====================
all data must be key-value pairs in data object
e.g. type == machine-abc-data
	- engine_temp = float
	- engine_rpm = integer
	- ...
==> when mobile app does store, we define the mappings in the data collection process:
	- val1 => engine_temp
	- val2 => integer
and the target type
	- machine-abc-data
===> will just create a new focus-data-container object with the key-value pairs,
	and submit it with type === machine-abc-data
... the backend is then responsible for checking the input (and possibly coerce it)
HENCE the app is schema agnostic, but we still keep some semantic and data validation
		but the app content designer must respect the semantic.